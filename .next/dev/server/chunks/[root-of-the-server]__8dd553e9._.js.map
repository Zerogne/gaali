{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/dnii/Documents/gaali/lib/db/client.ts"],"sourcesContent":["import { MongoClient, Db } from \"mongodb\"\n\nif (!process.env.MONGODB_URI) {\n  throw new Error('Invalid/Missing environment variable: \"MONGODB_URI\"')\n}\n\nconst uri = process.env.MONGODB_URI\nconst options = {}\n\nlet client: MongoClient\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development mode, use a global variable so that the value\n  // is preserved across module reloads caused by HMR (Hot Module Replacement).\n  let globalWithMongo = global as typeof globalThis & {\n    _mongoClientPromise?: Promise<MongoClient>\n  }\n\n  if (!globalWithMongo._mongoClientPromise) {\n    client = new MongoClient(uri, options)\n    globalWithMongo._mongoClientPromise = client.connect()\n  }\n  clientPromise = globalWithMongo._mongoClientPromise\n} else {\n  // In production mode, it's best to not use a global variable.\n  client = new MongoClient(uri, options)\n  clientPromise = client.connect()\n}\n\n// Export a module-scoped MongoClient promise. By doing this in a\n// separate module, the client can be shared across functions.\nexport default clientPromise\n\n/**\n * Get the main database instance\n */\nexport async function getDatabase(): Promise<Db> {\n  const client = await clientPromise\n  return client.db(process.env.MONGODB_DB_NAME || \"truck-weighing-dashboard\")\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,WAAW,EAAE;IAC5B,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,MAAM,UAAU,CAAC;AAEjB,IAAI;AACJ,IAAI;AAEJ,wCAA4C;IAC1C,+DAA+D;IAC/D,6EAA6E;IAC7E,IAAI;IAIJ,IAAI,CAAC,gBAAgB,mBAAmB,EAAE;QACxC,SAAS,IAAI,sHAAW,CAAC,KAAK;QAC9B,gBAAgB,mBAAmB,GAAG,OAAO,OAAO;IACtD;IACA,gBAAgB,gBAAgB,mBAAmB;AACrD;;uCAQe;AAKR,eAAe;IACpB,MAAM,SAAS,MAAM;IACrB,OAAO,OAAO,EAAE,CAAC,QAAQ,GAAG,CAAC,eAAe,IAAI;AAClD"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///Users/dnii/Documents/gaali/lib/db/companyDb.ts"],"sourcesContent":["import { Collection, Db } from \"mongodb\"\nimport { getDatabase } from \"./client\"\n\n/**\n * Get a company-scoped collection.\n * This is the ONLY method that should be used to access company data.\n * \n * Pattern: company_{companyId}_{collectionName}\n * \n * Examples:\n * - company_altan-logistics_logs\n * - company_altan-logistics_workers\n * - company_altan-logistics_sessions\n * \n * @param companyId - The company identifier\n * @param collectionName - The collection name (e.g., 'logs', 'workers', 'sessions')\n * @returns MongoDB Collection instance scoped to the company\n */\nexport async function getCompanyCollection<T = any>(\n  companyId: string,\n  collectionName: string\n): Promise<Collection<T & any>> {\n  if (!companyId || !collectionName) {\n    throw new Error(\"companyId and collectionName are required\")\n  }\n\n  const db = await getDatabase()\n  const collectionNameWithPrefix = `company_${companyId}_${collectionName}`\n  \n  return db.collection<T & any>(collectionNameWithPrefix)\n}\n\n/**\n * Get the company database instance (for operations that need the DB object)\n * @param companyId - The company identifier\n * @returns MongoDB Db instance\n */\nexport async function getCompanyDB(companyId: string): Promise<Db> {\n  if (!companyId) {\n    throw new Error(\"companyId is required\")\n  }\n  \n  return getDatabase()\n}\n\n/**\n * Get the global companies metadata collection\n * This is the ONLY shared collection across all companies\n */\nexport async function getCompaniesCollection() {\n  const db = await getDatabase()\n  return db.collection(\"companies\")\n}\n\n/**\n * Ensure company collections exist (optional helper for initialization)\n * Creates indexes for better query performance\n */\nexport async function ensureCompanyCollections(companyId: string) {\n  const collections = [\"logs\", \"workers\", \"sessions\", \"settings\", \"products\", \"truck_sessions\"]\n  \n  for (const collectionName of collections) {\n    const collection = await getCompanyCollection(companyId, collectionName)\n    \n    // Create indexes for common queries\n    if (collectionName === \"logs\") {\n      await collection.createIndex({ createdAt: -1 })\n      await collection.createIndex({ direction: 1 })\n      await collection.createIndex({ sentToCustoms: 1 })\n      await collection.createIndex({ plate: 1 })\n    } else if (collectionName === \"workers\") {\n      await collection.createIndex({ companyId: 1 })\n      await collection.createIndex({ id: 1 }, { unique: true })\n    } else if (collectionName === \"sessions\") {\n      await collection.createIndex({ workerId: 1 })\n      await collection.createIndex({ createdAt: -1 })\n    } else if (collectionName === \"products\") {\n      await collection.createIndex({ value: 1 }, { unique: true })\n      await collection.createIndex({ isCustom: 1 })\n    } else if (collectionName === \"truck_sessions\") {\n      await collection.createIndex({ createdAt: -1 })\n      await collection.createIndex({ direction: 1 })\n      await collection.createIndex({ plateNumber: 1 })\n      await collection.createIndex({ inSessionId: 1 })\n      await collection.createIndex({ companyId: 1 })\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;AACA;;AAiBO,eAAe,qBACpB,SAAiB,EACjB,cAAsB;IAEtB,IAAI,CAAC,aAAa,CAAC,gBAAgB;QACjC,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,MAAM,IAAA,oIAAW;IAC5B,MAAM,2BAA2B,CAAC,QAAQ,EAAE,UAAU,CAAC,EAAE,gBAAgB;IAEzE,OAAO,GAAG,UAAU,CAAU;AAChC;AAOO,eAAe,aAAa,SAAiB;IAClD,IAAI,CAAC,WAAW;QACd,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAA,oIAAW;AACpB;AAMO,eAAe;IACpB,MAAM,KAAK,MAAM,IAAA,oIAAW;IAC5B,OAAO,GAAG,UAAU,CAAC;AACvB;AAMO,eAAe,yBAAyB,SAAiB;IAC9D,MAAM,cAAc;QAAC;QAAQ;QAAW;QAAY;QAAY;QAAY;KAAiB;IAE7F,KAAK,MAAM,kBAAkB,YAAa;QACxC,MAAM,aAAa,MAAM,qBAAqB,WAAW;QAEzD,oCAAoC;QACpC,IAAI,mBAAmB,QAAQ;YAC7B,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW,CAAC;YAAE;YAC7C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC5C,MAAM,WAAW,WAAW,CAAC;gBAAE,eAAe;YAAE;YAChD,MAAM,WAAW,WAAW,CAAC;gBAAE,OAAO;YAAE;QAC1C,OAAO,IAAI,mBAAmB,WAAW;YACvC,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC5C,MAAM,WAAW,WAAW,CAAC;gBAAE,IAAI;YAAE,GAAG;gBAAE,QAAQ;YAAK;QACzD,OAAO,IAAI,mBAAmB,YAAY;YACxC,MAAM,WAAW,WAAW,CAAC;gBAAE,UAAU;YAAE;YAC3C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW,CAAC;YAAE;QAC/C,OAAO,IAAI,mBAAmB,YAAY;YACxC,MAAM,WAAW,WAAW,CAAC;gBAAE,OAAO;YAAE,GAAG;gBAAE,QAAQ;YAAK;YAC1D,MAAM,WAAW,WAAW,CAAC;gBAAE,UAAU;YAAE;QAC7C,OAAO,IAAI,mBAAmB,kBAAkB;YAC9C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW,CAAC;YAAE;YAC7C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC5C,MAAM,WAAW,WAAW,CAAC;gBAAE,aAAa;YAAE;YAC9C,MAAM,WAAW,WAAW,CAAC;gBAAE,aAAa;YAAE;YAC9C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;QAC9C;IACF;AACF"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///Users/dnii/Documents/gaali/lib/auth/session.ts"],"sourcesContent":["\"use server\"\n\nimport { cookies } from \"next/headers\"\nimport { redirect } from \"next/navigation\"\n\nconst COMPANY_ID_COOKIE = \"company-id\"\nconst WORKER_ID_COOKIE = \"worker-id\"\nconst SESSION_EXPIRES_COOKIE = \"session-expires\"\n\n// Session duration: 7 days (in seconds)\nconst SESSION_MAX_AGE = 60 * 60 * 24 * 7\n\n// Check if cookies should be secure (production or forced)\nconst isSecure = process.env.NODE_ENV === \"production\" || process.env.FORCE_SECURE_COOKIES === \"true\"\n\nexport interface SessionData {\n  companyId: string\n  workerId: string\n  expiresAt: number\n}\n\n/**\n * Get the active company context from session\n * Throws if no company is set (forces login)\n * Validates session expiration\n */\nexport async function getActiveCompany(): Promise<string> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId) {\n    redirect(\"/login\")\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      // Session expired, clear and redirect\n      await clearSession()\n      redirect(\"/login\")\n    }\n  }\n\n  return companyId\n}\n\n/**\n * Get the current session data (companyId + workerId)\n * Returns null if not authenticated or expired\n */\nexport async function getSession(): Promise<SessionData | null> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const workerId = cookieStore.get(WORKER_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId || !workerId) {\n    return null\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      // Session expired\n      await clearSession()\n      return null\n    }\n  }\n\n  return {\n    companyId,\n    workerId,\n    expiresAt: expiresAt ? parseInt(expiresAt, 10) : Date.now() + SESSION_MAX_AGE * 1000,\n  }\n}\n\n/**\n * Set session expiration timestamp\n */\nfunction setSessionExpiration(cookieStore: ReturnType<typeof cookies>) {\n  const expiresAt = Date.now() + SESSION_MAX_AGE * 1000\n  cookieStore.set(SESSION_EXPIRES_COOKIE, expiresAt.toString(), {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n}\n\n/**\n * Set session after successful login\n * Includes expiration timestamp\n */\nexport async function setSession(companyId: string, workerId: string) {\n  const cookieStore = await cookies()\n  \n  // Validate inputs\n  if (!companyId || !workerId) {\n    throw new Error(\"Company ID and Worker ID are required\")\n  }\n\n  // Set cookies with httpOnly for security\n  cookieStore.set(COMPANY_ID_COOKIE, companyId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  cookieStore.set(WORKER_ID_COOKIE, workerId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Set company session (partial session - company logged in, worker not selected yet)\n * Includes expiration timestamp\n */\nexport async function setCompanySession(companyId: string) {\n  const cookieStore = await cookies()\n  \n  if (!companyId) {\n    throw new Error(\"Company ID is required\")\n  }\n\n  cookieStore.set(COMPANY_ID_COOKIE, companyId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Set worker ID in existing company session\n * Refreshes expiration\n */\nexport async function setWorkerInSession(workerId: string) {\n  const cookieStore = await cookies()\n  \n  if (!workerId) {\n    throw new Error(\"Worker ID is required\")\n  }\n\n  // Verify company session exists\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  if (!companyId) {\n    throw new Error(\"Company session not found\")\n  }\n\n  cookieStore.set(WORKER_ID_COOKIE, workerId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Refresh session expiration\n */\nexport async function refreshSession() {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const workerId = cookieStore.get(WORKER_ID_COOKIE)?.value\n\n  if (companyId && workerId) {\n    setSessionExpiration(cookieStore)\n  }\n}\n\n/**\n * Clear session on logout\n */\nexport async function clearSession() {\n  const cookieStore = await cookies()\n  cookieStore.delete(COMPANY_ID_COOKIE)\n  cookieStore.delete(WORKER_ID_COOKIE)\n  cookieStore.delete(SESSION_EXPIRES_COOKIE)\n}\n\n/**\n * Check if user is authenticated (both company and worker)\n * Also checks expiration\n */\nexport async function isAuthenticated(): Promise<boolean> {\n  const session = await getSession()\n  return session !== null\n}\n\n/**\n * Check if company is logged in (partial authentication)\n * Also checks expiration\n */\nexport async function isCompanyAuthenticated(): Promise<boolean> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId) {\n    return false\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      return false\n    }\n  }\n\n  return true\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":["file:///Users/dnii/Documents/gaali/lib/errors.ts"],"sourcesContent":["/**\n * Centralized error handling utilities\n * Provides consistent error types and handling across the application\n */\n\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public statusCode: number = 500,\n    public isOperational: boolean = true\n  ) {\n    super(message)\n    this.name = 'AppError'\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string, public fields?: Record<string, string>) {\n    super(message, 'VALIDATION_ERROR', 400, true)\n    this.name = 'ValidationError'\n  }\n}\n\nexport class AuthenticationError extends AppError {\n  constructor(message: string = 'Authentication required') {\n    super(message, 'AUTHENTICATION_ERROR', 401, true)\n    this.name = 'AuthenticationError'\n  }\n}\n\nexport class AuthorizationError extends AppError {\n  constructor(message: string = 'Insufficient permissions') {\n    super(message, 'AUTHORIZATION_ERROR', 403, true)\n    this.name = 'AuthorizationError'\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(message: string = 'Resource not found') {\n    super(message, 'NOT_FOUND', 404, true)\n    this.name = 'NotFoundError'\n  }\n}\n\nexport class RateLimitError extends AppError {\n  constructor(message: string = 'Too many requests', public retryAfter?: number) {\n    super(message, 'RATE_LIMIT_ERROR', 429, true)\n    this.name = 'RateLimitError'\n  }\n}\n\n/**\n * Handle errors and return user-friendly messages\n * Never expose internal error details in production\n */\nexport function handleError(error: unknown): { message: string; code: string; statusCode: number } {\n  // Known operational errors\n  if (error instanceof AppError) {\n    return {\n      message: error.message,\n      code: error.code,\n      statusCode: error.statusCode,\n    }\n  }\n\n  // Validation errors from Zod\n  if (error && typeof error === 'object' && 'issues' in error) {\n    const zodError = error as { issues: Array<{ path: string[]; message: string }> }\n    const messages = zodError.issues.map((issue) => issue.message).join(', ')\n    return {\n      message: `Validation failed: ${messages}`,\n      code: 'VALIDATION_ERROR',\n      statusCode: 400,\n    }\n  }\n\n  // Standard Error objects\n  if (error instanceof Error) {\n    // Log full error in development, but don't expose to user\n    if (process.env.NODE_ENV === 'development') {\n      console.error('Error details:', error)\n    }\n    return {\n      message: process.env.NODE_ENV === 'production'\n        ? 'An error occurred. Please try again.'\n        : error.message,\n      code: 'INTERNAL_ERROR',\n      statusCode: 500,\n    }\n  }\n\n  // Unknown error types\n  console.error('Unknown error type:', error)\n  return {\n    message: process.env.NODE_ENV === 'production'\n      ? 'An unexpected error occurred'\n      : String(error),\n    code: 'UNKNOWN_ERROR',\n    statusCode: 500,\n  }\n}\n\n/**\n * Convert error to JSON response format\n */\nexport function errorToResponse(error: unknown) {\n  const handled = handleError(error)\n  return {\n    error: handled.message,\n    code: handled.code,\n    ...(process.env.NODE_ENV === 'development' && error instanceof Error\n      ? { stack: error.stack }\n      : {}),\n  }\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;AAEM,MAAM,iBAAiB;;;;IAC5B,YACE,OAAe,EACf,AAAO,IAAY,EACnB,AAAO,aAAqB,GAAG,EAC/B,AAAO,gBAAyB,IAAI,CACpC;QACA,KAAK,CAAC,eAJC,OAAA,WACA,aAAA,iBACA,gBAAA;QAGP,IAAI,CAAC,IAAI,GAAG;QACZ,MAAM,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW;IAChD;AACF;AAEO,MAAM,wBAAwB;;IACnC,YAAY,OAAe,EAAE,AAAO,MAA+B,CAAE;QACnE,KAAK,CAAC,SAAS,oBAAoB,KAAK,YADN,SAAA;QAElC,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,4BAA4B;IACvC,YAAY,UAAkB,yBAAyB,CAAE;QACvD,KAAK,CAAC,SAAS,wBAAwB,KAAK;QAC5C,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,2BAA2B;IACtC,YAAY,UAAkB,0BAA0B,CAAE;QACxD,KAAK,CAAC,SAAS,uBAAuB,KAAK;QAC3C,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,sBAAsB;IACjC,YAAY,UAAkB,oBAAoB,CAAE;QAClD,KAAK,CAAC,SAAS,aAAa,KAAK;QACjC,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,uBAAuB;;IAClC,YAAY,UAAkB,mBAAmB,EAAE,AAAO,UAAmB,CAAE;QAC7E,KAAK,CAAC,SAAS,oBAAoB,KAAK,YADgB,aAAA;QAExD,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAMO,SAAS,YAAY,KAAc;IACxC,2BAA2B;IAC3B,IAAI,iBAAiB,UAAU;QAC7B,OAAO;YACL,SAAS,MAAM,OAAO;YACtB,MAAM,MAAM,IAAI;YAChB,YAAY,MAAM,UAAU;QAC9B;IACF;IAEA,6BAA6B;IAC7B,IAAI,SAAS,OAAO,UAAU,YAAY,YAAY,OAAO;QAC3D,MAAM,WAAW;QACjB,MAAM,WAAW,SAAS,MAAM,CAAC,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;QACpE,OAAO;YACL,SAAS,CAAC,mBAAmB,EAAE,UAAU;YACzC,MAAM;YACN,YAAY;QACd;IACF;IAEA,yBAAyB;IACzB,IAAI,iBAAiB,OAAO;QAC1B,0DAA0D;QAC1D,wCAA4C;YAC1C,QAAQ,KAAK,CAAC,kBAAkB;QAClC;QACA,OAAO;YACL,SAAS,sCACL,0BACA,MAAM,OAAO;YACjB,MAAM;YACN,YAAY;QACd;IACF;IAEA,sBAAsB;IACtB,QAAQ,KAAK,CAAC,uBAAuB;IACrC,OAAO;QACL,SAAS,sCACL,0BACA,OAAO;QACX,MAAM;QACN,YAAY;IACd;AACF;AAKO,SAAS,gBAAgB,KAAc;IAC5C,MAAM,UAAU,YAAY;IAC5B,OAAO;QACL,OAAO,QAAQ,OAAO;QACtB,MAAM,QAAQ,IAAI;QAClB,GAAI,oDAAyB,iBAAiB,iBAAiB,QAC3D;YAAE,OAAO,MAAM,KAAK;QAAC,IACrB,CAAC,CAAC;IACR;AACF"}},
    {"offset": {"line": 515, "column": 0}, "map": {"version":3,"sources":["file:///Users/dnii/Documents/gaali/lib/truckSessions.ts"],"sourcesContent":["\"use server\"\n\nimport { ObjectId } from \"mongodb\"\nimport { getCompanyCollection } from \"@/lib/db/companyDb\"\nimport { getActiveCompany } from \"@/lib/auth/session\"\nimport { handleError, ValidationError } from \"@/lib/errors\"\nimport { z } from \"zod\"\n\nexport type SessionDirection = \"IN\" | \"OUT\"\n\n// Validation schema for truck session\nconst truckSessionSchema = z.object({\n  direction: z.enum([\"IN\", \"OUT\"]),\n  plateNumber: z.string().min(1, \"Plate number is required\"),\n  driverName: z.string().optional(),\n  product: z.string().optional(),\n  transporterCompany: z.string().optional(),\n  inSessionId: z.string().optional(),\n  grossWeightKg: z.number().positive(\"Gross weight must be positive\"),\n  netWeightKg: z.number().positive().optional(),\n  inTime: z.string().optional(),\n  outTime: z.string().optional(),\n  notes: z.string().optional(),\n})\n\nexport interface TruckSession {\n  _id?: ObjectId\n  id: string // Custom ID for client-side use\n  companyId: string\n  direction: SessionDirection\n  plateNumber: string\n  driverName?: string\n  product?: string\n  transporterCompany?: string\n  inSessionId?: string // Links to IN session for OUT sessions\n  grossWeightKg: number\n  netWeightKg?: number // Only for OUT sessions\n  inTime?: string // ISO string for IN sessions\n  outTime?: string // ISO string for OUT sessions\n  notes?: string\n  createdAt: Date\n  updatedAt: Date\n}\n\n/**\n * Save a truck session (IN or OUT) to company-scoped collection\n * Uses the active company from session\n * Includes input validation\n */\nexport async function saveTruckSession(\n  sessionData: Omit<TruckSession, \"_id\" | \"id\" | \"companyId\" | \"createdAt\" | \"updatedAt\">\n): Promise<TruckSession> {\n  try {\n    // Validate input\n    const validation = truckSessionSchema.safeParse(sessionData)\n    if (!validation.success) {\n      throw new ValidationError(\n        \"Invalid truck session data\",\n        validation.error.issues.reduce((acc, issue) => {\n          const path = issue.path.join(\".\")\n          acc[path] = issue.message\n          return acc\n        }, {} as Record<string, string>)\n      )\n    }\n\n    // Get active company from session\n    const companyId = await getActiveCompany()\n\n    // Get company-scoped sessions collection\n    const sessionsCollection = await getCompanyCollection<TruckSession>(\n      companyId,\n      \"truck_sessions\"\n    )\n\n    // Create session document\n    const now = new Date()\n    const sessionDoc: TruckSession = {\n      ...validation.data,\n      id: `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      companyId,\n      createdAt: now,\n      updatedAt: now,\n    }\n\n    // Insert into company's collection\n    await sessionsCollection.insertOne(sessionDoc)\n\n    // Serialize MongoDB document to plain object\n    const serializedSession: TruckSession = {\n      id: sessionDoc.id,\n      companyId: sessionDoc.companyId,\n      direction: sessionDoc.direction,\n      plateNumber: sessionDoc.plateNumber,\n      driverName: sessionDoc.driverName,\n      product: sessionDoc.product,\n      transporterCompany: sessionDoc.transporterCompany,\n      inSessionId: sessionDoc.inSessionId,\n      grossWeightKg: sessionDoc.grossWeightKg,\n      netWeightKg: sessionDoc.netWeightKg,\n      inTime: sessionDoc.inTime,\n      outTime: sessionDoc.outTime,\n      notes: sessionDoc.notes,\n      createdAt: sessionDoc.createdAt,\n      updatedAt: sessionDoc.updatedAt,\n    }\n\n    return serializedSession\n  } catch (error) {\n    const handled = handleError(error)\n    throw new Error(handled.message)\n  }\n}\n\n/**\n * Get truck sessions for the active company with optional filters\n * Serializes MongoDB documents to plain objects for Client Components\n */\nexport async function getTruckSessions(options?: {\n  direction?: SessionDirection\n  plateNumber?: string\n  startDate?: Date | string\n  endDate?: Date | string\n  limit?: number\n  page?: number\n}): Promise<{\n  sessions: TruckSession[]\n  total: number\n  page: number\n  limit: number\n  totalPages: number\n}> {\n  try {\n    const companyId = await getActiveCompany()\n    const sessionsCollection = await getCompanyCollection<TruckSession>(\n      companyId,\n      \"truck_sessions\"\n    )\n\n    // Build query filter\n    const filter: any = {}\n    if (options?.direction) {\n      filter.direction = options.direction\n    }\n    if (options?.plateNumber) {\n      filter.plateNumber = { $regex: options.plateNumber, $options: \"i\" }\n    }\n    \n    // Date range filter\n    if (options?.startDate || options?.endDate) {\n      filter.createdAt = {}\n      if (options.startDate) {\n        const start = options.startDate instanceof Date \n          ? options.startDate \n          : new Date(options.startDate)\n        filter.createdAt.$gte = start\n      }\n      if (options.endDate) {\n        const end = options.endDate instanceof Date \n          ? options.endDate \n          : new Date(options.endDate)\n        // Set to end of day\n        end.setHours(23, 59, 59, 999)\n        filter.createdAt.$lte = end\n      }\n    }\n\n    // Pagination\n    const page = Math.max(1, options?.page || 1)\n    const limit = Math.min(100, Math.max(1, options?.limit || 50))\n    const skip = (page - 1) * limit\n\n    // Get total count\n    const total = await sessionsCollection.countDocuments(filter)\n\n    // Fetch sessions with pagination, sorted by creation date (newest first)\n    const sessions = await sessionsCollection\n      .find(filter)\n      .sort({ createdAt: -1 })\n      .skip(skip)\n      .limit(limit)\n      .toArray()\n\n    // Serialize MongoDB documents to plain objects\n    const serializedSessions = sessions.map((doc) => {\n      const { _id, ...session } = doc\n      return {\n        ...session,\n        createdAt: session.createdAt instanceof Date \n          ? session.createdAt \n          : typeof session.createdAt === 'string'\n            ? new Date(session.createdAt)\n            : new Date(session.createdAt),\n        updatedAt: session.updatedAt instanceof Date \n          ? session.updatedAt \n          : typeof session.updatedAt === 'string'\n            ? new Date(session.updatedAt)\n            : new Date(session.updatedAt),\n      } as TruckSession\n    })\n\n    return {\n      sessions: serializedSessions,\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit),\n    }\n  } catch (error) {\n    const handled = handleError(error)\n    throw new Error(handled.message)\n  }\n}\n\n/**\n * Get a single truck session by ID (company-scoped)\n * Serializes MongoDB document to plain object for Client Components\n */\nexport async function getTruckSession(sessionId: string): Promise<TruckSession | null> {\n  try {\n    const companyId = await getActiveCompany()\n    const sessionsCollection = await getCompanyCollection<TruckSession>(\n      companyId,\n      \"truck_sessions\"\n    )\n\n    const session = await sessionsCollection.findOne({ id: sessionId })\n\n    if (!session) return null\n\n    // Serialize MongoDB document to plain object\n    const { _id, ...sessionData } = session\n    return {\n      ...sessionData,\n      createdAt: sessionData.createdAt instanceof Date ? sessionData.createdAt : new Date(sessionData.createdAt),\n      updatedAt: sessionData.updatedAt instanceof Date ? sessionData.updatedAt : new Date(sessionData.updatedAt),\n    } as TruckSession\n  } catch (error) {\n    const handled = handleError(error)\n    throw new Error(handled.message)\n  }\n}\n\n/**\n * Find the most recent IN session for a given plate number\n * Used by OUT sessions to calculate net weight\n */\nexport async function findLatestInSession(\n  plateNumber: string\n): Promise<TruckSession | null> {\n  try {\n    const companyId = await getActiveCompany()\n    const sessionsCollection = await getCompanyCollection<TruckSession>(\n      companyId,\n      \"truck_sessions\"\n    )\n\n    const inSession = await sessionsCollection\n      .findOne(\n        {\n          direction: \"IN\",\n          plateNumber: plateNumber.trim().toUpperCase(),\n          grossWeightKg: { $gt: 0 },\n        },\n        { sort: { createdAt: -1 } }\n      )\n\n    if (!inSession) return null\n\n    // Serialize MongoDB document to plain object\n    const { _id, ...sessionData } = inSession\n    return {\n      ...sessionData,\n      createdAt: sessionData.createdAt instanceof Date ? sessionData.createdAt : new Date(sessionData.createdAt),\n      updatedAt: sessionData.updatedAt instanceof Date ? sessionData.updatedAt : new Date(sessionData.updatedAt),\n    } as TruckSession\n  } catch (error) {\n    const handled = handleError(error)\n    throw new Error(handled.message)\n  }\n}\n\n/**\n * Update an existing truck session\n */\nexport async function updateTruckSession(\n  sessionId: string,\n  updates: Partial<Omit<TruckSession, \"_id\" | \"id\" | \"companyId\" | \"createdAt\">>\n): Promise<TruckSession | null> {\n  try {\n    const companyId = await getActiveCompany()\n    const sessionsCollection = await getCompanyCollection<TruckSession>(\n      companyId,\n      \"truck_sessions\"\n    )\n\n    const existingSession = await sessionsCollection.findOne({ id: sessionId })\n\n    if (!existingSession) {\n      return null\n    }\n\n    // Validate updates if provided\n    if (Object.keys(updates).length > 0) {\n      const validation = truckSessionSchema.partial().safeParse(updates)\n      if (!validation.success) {\n        throw new ValidationError(\n          \"Invalid update data\",\n          validation.error.issues.reduce((acc, issue) => {\n            const path = issue.path.join(\".\")\n            acc[path] = issue.message\n            return acc\n          }, {} as Record<string, string>)\n        )\n      }\n    }\n\n    // Update the session\n    const updateDoc = {\n      ...updates,\n      updatedAt: new Date(),\n    }\n\n    await sessionsCollection.updateOne({ id: sessionId }, { $set: updateDoc })\n\n    // Fetch updated session\n    const updatedSession = await sessionsCollection.findOne({ id: sessionId })\n\n    if (!updatedSession) return null\n\n    // Serialize MongoDB document to plain object\n    const { _id, ...sessionData } = updatedSession\n    return {\n      ...sessionData,\n      createdAt: sessionData.createdAt instanceof Date ? sessionData.createdAt : new Date(sessionData.createdAt),\n      updatedAt: sessionData.updatedAt instanceof Date ? sessionData.updatedAt : new Date(sessionData.updatedAt),\n    } as TruckSession\n  } catch (error) {\n    const handled = handleError(error)\n    throw new Error(handled.message)\n  }\n}\n\n/**\n * Delete a truck session\n */\nexport async function deleteTruckSession(sessionId: string): Promise<boolean> {\n  try {\n    const companyId = await getActiveCompany()\n    const sessionsCollection = await getCompanyCollection<TruckSession>(\n      companyId,\n      \"truck_sessions\"\n    )\n\n    const result = await sessionsCollection.deleteOne({ id: sessionId })\n\n    return result.deletedCount > 0\n  } catch (error) {\n    const handled = handleError(error)\n    throw new Error(handled.message)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"sources":["file:///Users/dnii/Documents/gaali/app/api/truck-sessions/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\nimport { saveTruckSession, getTruckSessions } from \"@/lib/truckSessions\"\nimport { errorToResponse } from \"@/lib/errors\"\n\n/**\n * POST /api/truck-sessions - Create a new truck session (IN or OUT)\n */\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json()\n\n    const session = await saveTruckSession({\n      direction: body.direction,\n      plateNumber: body.plateNumber,\n      driverName: body.driverName,\n      product: body.product,\n      transporterCompany: body.transporterCompany,\n      inSessionId: body.inSessionId,\n      grossWeightKg: body.grossWeightKg,\n      netWeightKg: body.netWeightKg,\n      inTime: body.inTime,\n      outTime: body.outTime,\n      notes: body.notes,\n    })\n\n    return NextResponse.json({ success: true, session }, { status: 201 })\n  } catch (error) {\n    console.error(\"Error creating truck session:\", error)\n    const errorResponse = errorToResponse(error)\n    const statusCode = error instanceof Error && \"statusCode\" in error\n      ? (error as { statusCode: number }).statusCode\n      : 500\n    return NextResponse.json(errorResponse, { status: statusCode })\n  }\n}\n\n/**\n * GET /api/truck-sessions - Get truck sessions with optional filters\n * Query params: direction, plateNumber, page, limit\n */\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const direction = searchParams.get(\"direction\") as \"IN\" | \"OUT\" | null\n    const plateNumber = searchParams.get(\"plateNumber\")\n    const startDate = searchParams.get(\"startDate\")\n    const endDate = searchParams.get(\"endDate\")\n    const page = parseInt(searchParams.get(\"page\") || \"1\", 10)\n    const limit = parseInt(searchParams.get(\"limit\") || \"50\", 10)\n\n    const result = await getTruckSessions({\n      direction: direction || undefined,\n      plateNumber: plateNumber || undefined,\n      startDate: startDate ? new Date(startDate) : undefined,\n      endDate: endDate ? new Date(endDate) : undefined,\n      page,\n      limit,\n    })\n\n    // Serialize dates to ISO strings for JSON response\n    const serializedResult = {\n      ...result,\n      sessions: result.sessions.map((session) => ({\n        ...session,\n        createdAt: session.createdAt instanceof Date \n          ? session.createdAt.toISOString() \n          : session.createdAt,\n        updatedAt: session.updatedAt instanceof Date \n          ? session.updatedAt.toISOString() \n          : session.updatedAt,\n      })),\n    }\n\n    return NextResponse.json(serializedResult, { status: 200 })\n  } catch (error) {\n    console.error(\"Error getting truck sessions:\", error)\n    const errorResponse = errorToResponse(error)\n    const statusCode = error instanceof Error && \"statusCode\" in error\n      ? (error as { statusCode: number }).statusCode\n      : 500\n    return NextResponse.json(errorResponse, { status: statusCode })\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAKO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,MAAM,UAAU,MAAM,IAAA,0IAAgB,EAAC;YACrC,WAAW,KAAK,SAAS;YACzB,aAAa,KAAK,WAAW;YAC7B,YAAY,KAAK,UAAU;YAC3B,SAAS,KAAK,OAAO;YACrB,oBAAoB,KAAK,kBAAkB;YAC3C,aAAa,KAAK,WAAW;YAC7B,eAAe,KAAK,aAAa;YACjC,aAAa,KAAK,WAAW;YAC7B,QAAQ,KAAK,MAAM;YACnB,SAAS,KAAK,OAAO;YACrB,OAAO,KAAK,KAAK;QACnB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM;QAAQ,GAAG;YAAE,QAAQ;QAAI;IACrE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM,gBAAgB,IAAA,kIAAe,EAAC;QACtC,MAAM,aAAa,iBAAiB,SAAS,gBAAgB,QACzD,AAAC,MAAiC,UAAU,GAC5C;QACJ,OAAO,gJAAY,CAAC,IAAI,CAAC,eAAe;YAAE,QAAQ;QAAW;IAC/D;AACF;AAMO,eAAe,IAAI,OAAgB;IACxC,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,cAAc,aAAa,GAAG,CAAC;QACrC,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,UAAU,aAAa,GAAG,CAAC;QACjC,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW,KAAK;QACvD,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY,MAAM;QAE1D,MAAM,SAAS,MAAM,IAAA,0IAAgB,EAAC;YACpC,WAAW,aAAa;YACxB,aAAa,eAAe;YAC5B,WAAW,YAAY,IAAI,KAAK,aAAa;YAC7C,SAAS,UAAU,IAAI,KAAK,WAAW;YACvC;YACA;QACF;QAEA,mDAAmD;QACnD,MAAM,mBAAmB;YACvB,GAAG,MAAM;YACT,UAAU,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,UAAY,CAAC;oBAC1C,GAAG,OAAO;oBACV,WAAW,QAAQ,SAAS,YAAY,OACpC,QAAQ,SAAS,CAAC,WAAW,KAC7B,QAAQ,SAAS;oBACrB,WAAW,QAAQ,SAAS,YAAY,OACpC,QAAQ,SAAS,CAAC,WAAW,KAC7B,QAAQ,SAAS;gBACvB,CAAC;QACH;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC,kBAAkB;YAAE,QAAQ;QAAI;IAC3D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM,gBAAgB,IAAA,kIAAe,EAAC;QACtC,MAAM,aAAa,iBAAiB,SAAS,gBAAgB,QACzD,AAAC,MAAiC,UAAU,GAC5C;QACJ,OAAO,gJAAY,CAAC,IAAI,CAAC,eAAe;YAAE,QAAQ;QAAW;IAC/D;AACF"}}]
}