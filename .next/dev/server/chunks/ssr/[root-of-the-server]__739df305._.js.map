{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/db/client.ts"],"sourcesContent":["import { MongoClient, Db } from \"mongodb\"\n\nif (!process.env.MONGODB_URI) {\n  throw new Error('Invalid/Missing environment variable: \"MONGODB_URI\"')\n}\n\nconst uri = process.env.MONGODB_URI\nconst options = {}\n\nlet client: MongoClient\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development mode, use a global variable so that the value\n  // is preserved across module reloads caused by HMR (Hot Module Replacement).\n  let globalWithMongo = global as typeof globalThis & {\n    _mongoClientPromise?: Promise<MongoClient>\n  }\n\n  if (!globalWithMongo._mongoClientPromise) {\n    client = new MongoClient(uri, options)\n    globalWithMongo._mongoClientPromise = client.connect()\n  }\n  clientPromise = globalWithMongo._mongoClientPromise\n} else {\n  // In production mode, it's best to not use a global variable.\n  client = new MongoClient(uri, options)\n  clientPromise = client.connect()\n}\n\n// Export a module-scoped MongoClient promise. By doing this in a\n// separate module, the client can be shared across functions.\nexport default clientPromise\n\n/**\n * Get the main database instance\n */\nexport async function getDatabase(): Promise<Db> {\n  const client = await clientPromise\n  return client.db(process.env.MONGODB_DB_NAME || \"truck-weighing-dashboard\")\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,WAAW,EAAE;IAC5B,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,MAAM,UAAU,CAAC;AAEjB,IAAI;AACJ,IAAI;AAEJ,wCAA4C;IAC1C,+DAA+D;IAC/D,6EAA6E;IAC7E,IAAI;IAIJ,IAAI,CAAC,gBAAgB,mBAAmB,EAAE;QACxC,SAAS,IAAI,sHAAW,CAAC,KAAK;QAC9B,gBAAgB,mBAAmB,GAAG,OAAO,OAAO;IACtD;IACA,gBAAgB,gBAAgB,mBAAmB;AACrD;;uCAQe;AAKR,eAAe;IACpB,MAAM,SAAS,MAAM;IACrB,OAAO,OAAO,EAAE,CAAC,QAAQ,GAAG,CAAC,eAAe,IAAI;AAClD"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/db/companyDb.ts"],"sourcesContent":["import { Collection, Db } from \"mongodb\"\nimport { getDatabase } from \"./client\"\n\n/**\n * Get a company-scoped collection.\n * This is the ONLY method that should be used to access company data.\n * \n * Pattern: company_{companyId}_{collectionName}\n * \n * Examples:\n * - company_altan-logistics_logs\n * - company_altan-logistics_workers\n * - company_altan-logistics_sessions\n * \n * @param companyId - The company identifier\n * @param collectionName - The collection name (e.g., 'logs', 'workers', 'sessions')\n * @returns MongoDB Collection instance scoped to the company\n */\nexport async function getCompanyCollection<T = any>(\n  companyId: string,\n  collectionName: string\n): Promise<Collection<T & any>> {\n  if (!companyId || !collectionName) {\n    throw new Error(\"companyId and collectionName are required\")\n  }\n\n  const db = await getDatabase()\n  const collectionNameWithPrefix = `company_${companyId}_${collectionName}`\n  \n  return db.collection<T & any>(collectionNameWithPrefix)\n}\n\n/**\n * Get the company database instance (for operations that need the DB object)\n * @param companyId - The company identifier\n * @returns MongoDB Db instance\n */\nexport async function getCompanyDB(companyId: string): Promise<Db> {\n  if (!companyId) {\n    throw new Error(\"companyId is required\")\n  }\n  \n  return getDatabase()\n}\n\n/**\n * Get the global companies metadata collection\n * This is the ONLY shared collection across all companies\n */\nexport async function getCompaniesCollection() {\n  const db = await getDatabase()\n  return db.collection(\"companies\")\n}\n\n/**\n * Ensure company collections exist (optional helper for initialization)\n * Creates indexes for better query performance\n */\nexport async function ensureCompanyCollections(companyId: string) {\n  const collections = [\"logs\", \"workers\", \"sessions\", \"settings\", \"products\"]\n  \n  for (const collectionName of collections) {\n    const collection = await getCompanyCollection(companyId, collectionName)\n    \n    // Create indexes for common queries\n    if (collectionName === \"logs\") {\n      await collection.createIndex({ createdAt: -1 })\n      await collection.createIndex({ direction: 1 })\n      await collection.createIndex({ sentToCustoms: 1 })\n      await collection.createIndex({ plate: 1 })\n    } else if (collectionName === \"workers\") {\n      await collection.createIndex({ companyId: 1 })\n      await collection.createIndex({ id: 1 }, { unique: true })\n    } else if (collectionName === \"sessions\") {\n      await collection.createIndex({ workerId: 1 })\n      await collection.createIndex({ createdAt: -1 })\n    } else if (collectionName === \"products\") {\n      await collection.createIndex({ value: 1 }, { unique: true })\n      await collection.createIndex({ isCustom: 1 })\n    }\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AACA;;AAiBO,eAAe,qBACpB,SAAiB,EACjB,cAAsB;IAEtB,IAAI,CAAC,aAAa,CAAC,gBAAgB;QACjC,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,MAAM,IAAA,kIAAW;IAC5B,MAAM,2BAA2B,CAAC,QAAQ,EAAE,UAAU,CAAC,EAAE,gBAAgB;IAEzE,OAAO,GAAG,UAAU,CAAU;AAChC;AAOO,eAAe,aAAa,SAAiB;IAClD,IAAI,CAAC,WAAW;QACd,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAA,kIAAW;AACpB;AAMO,eAAe;IACpB,MAAM,KAAK,MAAM,IAAA,kIAAW;IAC5B,OAAO,GAAG,UAAU,CAAC;AACvB;AAMO,eAAe,yBAAyB,SAAiB;IAC9D,MAAM,cAAc;QAAC;QAAQ;QAAW;QAAY;QAAY;KAAW;IAE3E,KAAK,MAAM,kBAAkB,YAAa;QACxC,MAAM,aAAa,MAAM,qBAAqB,WAAW;QAEzD,oCAAoC;QACpC,IAAI,mBAAmB,QAAQ;YAC7B,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW,CAAC;YAAE;YAC7C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC5C,MAAM,WAAW,WAAW,CAAC;gBAAE,eAAe;YAAE;YAChD,MAAM,WAAW,WAAW,CAAC;gBAAE,OAAO;YAAE;QAC1C,OAAO,IAAI,mBAAmB,WAAW;YACvC,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC5C,MAAM,WAAW,WAAW,CAAC;gBAAE,IAAI;YAAE,GAAG;gBAAE,QAAQ;YAAK;QACzD,OAAO,IAAI,mBAAmB,YAAY;YACxC,MAAM,WAAW,WAAW,CAAC;gBAAE,UAAU;YAAE;YAC3C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW,CAAC;YAAE;QAC/C,OAAO,IAAI,mBAAmB,YAAY;YACxC,MAAM,WAAW,WAAW,CAAC;gBAAE,OAAO;YAAE,GAAG;gBAAE,QAAQ;YAAK;YAC1D,MAAM,WAAW,WAAW,CAAC;gBAAE,UAAU;YAAE;QAC7C;IACF;AACF"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/auth/session.ts"],"sourcesContent":["\"use server\"\n\nimport { cookies } from \"next/headers\"\nimport { redirect } from \"next/navigation\"\n\nconst COMPANY_ID_COOKIE = \"company-id\"\nconst WORKER_ID_COOKIE = \"worker-id\"\nconst SESSION_EXPIRES_COOKIE = \"session-expires\"\n\n// Session duration: 7 days (in seconds)\nconst SESSION_MAX_AGE = 60 * 60 * 24 * 7\n\n// Check if cookies should be secure (production or forced)\nconst isSecure = process.env.NODE_ENV === \"production\" || process.env.FORCE_SECURE_COOKIES === \"true\"\n\nexport interface SessionData {\n  companyId: string\n  workerId: string\n  expiresAt: number\n}\n\n/**\n * Get the active company context from session\n * Throws if no company is set (forces login)\n * Validates session expiration\n */\nexport async function getActiveCompany(): Promise<string> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId) {\n    redirect(\"/login\")\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      // Session expired, clear and redirect\n      await clearSession()\n      redirect(\"/login\")\n    }\n  }\n\n  return companyId\n}\n\n/**\n * Get the current session data (companyId + workerId)\n * Returns null if not authenticated or expired\n */\nexport async function getSession(): Promise<SessionData | null> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const workerId = cookieStore.get(WORKER_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId || !workerId) {\n    return null\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      // Session expired\n      await clearSession()\n      return null\n    }\n  }\n\n  return {\n    companyId,\n    workerId,\n    expiresAt: expiresAt ? parseInt(expiresAt, 10) : Date.now() + SESSION_MAX_AGE * 1000,\n  }\n}\n\n/**\n * Set session expiration timestamp\n */\nfunction setSessionExpiration(cookieStore: ReturnType<typeof cookies>) {\n  const expiresAt = Date.now() + SESSION_MAX_AGE * 1000\n  cookieStore.set(SESSION_EXPIRES_COOKIE, expiresAt.toString(), {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n}\n\n/**\n * Set session after successful login\n * Includes expiration timestamp\n */\nexport async function setSession(companyId: string, workerId: string) {\n  const cookieStore = await cookies()\n  \n  // Validate inputs\n  if (!companyId || !workerId) {\n    throw new Error(\"Company ID and Worker ID are required\")\n  }\n\n  // Set cookies with httpOnly for security\n  cookieStore.set(COMPANY_ID_COOKIE, companyId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  cookieStore.set(WORKER_ID_COOKIE, workerId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Set company session (partial session - company logged in, worker not selected yet)\n * Includes expiration timestamp\n */\nexport async function setCompanySession(companyId: string) {\n  const cookieStore = await cookies()\n  \n  if (!companyId) {\n    throw new Error(\"Company ID is required\")\n  }\n\n  cookieStore.set(COMPANY_ID_COOKIE, companyId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Set worker ID in existing company session\n * Refreshes expiration\n */\nexport async function setWorkerInSession(workerId: string) {\n  const cookieStore = await cookies()\n  \n  if (!workerId) {\n    throw new Error(\"Worker ID is required\")\n  }\n\n  // Verify company session exists\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  if (!companyId) {\n    throw new Error(\"Company session not found\")\n  }\n\n  cookieStore.set(WORKER_ID_COOKIE, workerId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Refresh session expiration\n */\nexport async function refreshSession() {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const workerId = cookieStore.get(WORKER_ID_COOKIE)?.value\n\n  if (companyId && workerId) {\n    setSessionExpiration(cookieStore)\n  }\n}\n\n/**\n * Clear session on logout\n */\nexport async function clearSession() {\n  const cookieStore = await cookies()\n  cookieStore.delete(COMPANY_ID_COOKIE)\n  cookieStore.delete(WORKER_ID_COOKIE)\n  cookieStore.delete(SESSION_EXPIRES_COOKIE)\n}\n\n/**\n * Check if user is authenticated (both company and worker)\n * Also checks expiration\n */\nexport async function isAuthenticated(): Promise<boolean> {\n  const session = await getSession()\n  return session !== null\n}\n\n/**\n * Check if company is logged in (partial authentication)\n * Also checks expiration\n */\nexport async function isCompanyAuthenticated(): Promise<boolean> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId) {\n    return false\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      return false\n    }\n  }\n\n  return true\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 334, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/api.ts"],"sourcesContent":["\"use server\"\n\nimport { getCompanyCollection } from \"@/lib/db/companyDb\"\nimport { getActiveCompany } from \"@/lib/auth/session\"\nimport type { TruckLog } from \"./types\"\n\n/**\n * Save truck log to company-scoped collection\n * Uses the active company from session\n */\nexport async function saveTruckLog(\n  log: Omit<TruckLog, \"id\" | \"createdAt\" | \"sentToCustoms\">\n): Promise<TruckLog> {\n  // Get active company from session\n  const companyId = await getActiveCompany()\n\n  // Get company-scoped logs collection\n  const logsCollection = await getCompanyCollection<TruckLog>(companyId, \"logs\")\n\n  // Create log document\n  const logDoc: TruckLog = {\n    ...log,\n    id: `truck-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    createdAt: new Date().toISOString(),\n    sentToCustoms: false,\n  }\n\n  // Insert into company's collection\n  await logsCollection.insertOne(logDoc)\n\n  return logDoc\n}\n\n/**\n * Send truck log to customs\n * Reads from and updates company-scoped collection\n */\nexport async function sendTruckLogToCustoms(\n  logId: string\n): Promise<{ success: boolean; error?: string }> {\n  try {\n    // Get active company from session\n    const companyId = await getActiveCompany()\n\n    // Get company-scoped logs collection\n    const logsCollection = await getCompanyCollection<TruckLog>(companyId, \"logs\")\n\n    // Find the log in company's collection\n    const log = await logsCollection.findOne({ id: logId })\n\n    if (!log) {\n      return {\n        success: false,\n        error: \"Log not found\",\n      }\n    }\n\n    // Simulate network delay\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n\n    // Simulate occasional network errors (10% chance)\n    if (Math.random() < 0.1) {\n      return {\n        success: false,\n        error: \"Network error: Unable to connect to customs system\",\n      }\n    }\n\n    // Update log status in company's collection\n    await logsCollection.updateOne(\n      { id: logId },\n      { $set: { sentToCustoms: true } }\n    )\n\n    return { success: true }\n  } catch (error) {\n    console.error(\"Error sending to customs:\", error)\n    return {\n      success: false,\n      error: \"Failed to send to customs\",\n    }\n  }\n}\n\n/**\n * Get all truck logs for the active company\n * Serializes MongoDB documents to plain objects for Client Components\n */\nexport async function getTruckLogs(): Promise<TruckLog[]> {\n  const companyId = await getActiveCompany()\n  const logsCollection = await getCompanyCollection<TruckLog>(companyId, \"logs\")\n\n  // Fetch all logs, sorted by creation date (newest first)\n  const logs = await logsCollection\n    .find({})\n    .sort({ createdAt: -1 })\n    .toArray()\n\n  // Serialize MongoDB documents to plain objects\n  return logs.map((doc) => {\n    const { _id, createdAt, ...log } = doc as any\n    return {\n      ...log,\n      createdAt: typeof createdAt === 'string' \n        ? createdAt \n        : (createdAt instanceof Date \n            ? createdAt.toISOString() \n            : new Date(createdAt).toISOString()),\n    } as TruckLog\n  })\n}\n\n/**\n * Get a single truck log by ID (company-scoped)\n * Serializes MongoDB document to plain object for Client Components\n */\nexport async function getTruckLog(logId: string): Promise<TruckLog | null> {\n  const companyId = await getActiveCompany()\n  const logsCollection = await getCompanyCollection<TruckLog>(companyId, \"logs\")\n\n  const log = await logsCollection.findOne({ id: logId })\n  \n  if (!log) return null\n\n  // Serialize MongoDB document to plain object\n  const { _id, createdAt, ...logData } = log as any\n  return {\n    ...logData,\n    createdAt: typeof createdAt === 'string' \n      ? createdAt \n      : (createdAt instanceof Date \n          ? createdAt.toISOString() \n          : new Date(createdAt).toISOString()),\n  } as TruckLog\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAEA;AACA;;;;;AAOO,eAAe,aACpB,GAAyD;IAEzD,kCAAkC;IAClC,MAAM,YAAY,MAAM,IAAA,0IAAgB;IAExC,qCAAqC;IACrC,MAAM,iBAAiB,MAAM,IAAA,8IAAoB,EAAW,WAAW;IAEvE,sBAAsB;IACtB,MAAM,SAAmB;QACvB,GAAG,GAAG;QACN,IAAI,CAAC,MAAM,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI;QACpE,WAAW,IAAI,OAAO,WAAW;QACjC,eAAe;IACjB;IAEA,mCAAmC;IACnC,MAAM,eAAe,SAAS,CAAC;IAE/B,OAAO;AACT;AAMO,eAAe,sBACpB,KAAa;IAEb,IAAI;QACF,kCAAkC;QAClC,MAAM,YAAY,MAAM,IAAA,0IAAgB;QAExC,qCAAqC;QACrC,MAAM,iBAAiB,MAAM,IAAA,8IAAoB,EAAW,WAAW;QAEvE,uCAAuC;QACvC,MAAM,MAAM,MAAM,eAAe,OAAO,CAAC;YAAE,IAAI;QAAM;QAErD,IAAI,CAAC,KAAK;YACR,OAAO;gBACL,SAAS;gBACT,OAAO;YACT;QACF;QAEA,yBAAyB;QACzB,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;QAEnD,kDAAkD;QAClD,IAAI,KAAK,MAAM,KAAK,KAAK;YACvB,OAAO;gBACL,SAAS;gBACT,OAAO;YACT;QACF;QAEA,4CAA4C;QAC5C,MAAM,eAAe,SAAS,CAC5B;YAAE,IAAI;QAAM,GACZ;YAAE,MAAM;gBAAE,eAAe;YAAK;QAAE;QAGlC,OAAO;YAAE,SAAS;QAAK;IACzB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YACL,SAAS;YACT,OAAO;QACT;IACF;AACF;AAMO,eAAe;IACpB,MAAM,YAAY,MAAM,IAAA,0IAAgB;IACxC,MAAM,iBAAiB,MAAM,IAAA,8IAAoB,EAAW,WAAW;IAEvE,yDAAyD;IACzD,MAAM,OAAO,MAAM,eAChB,IAAI,CAAC,CAAC,GACN,IAAI,CAAC;QAAE,WAAW,CAAC;IAAE,GACrB,OAAO;IAEV,+CAA+C;IAC/C,OAAO,KAAK,GAAG,CAAC,CAAC;QACf,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG,KAAK,GAAG;QACnC,OAAO;YACL,GAAG,GAAG;YACN,WAAW,OAAO,cAAc,WAC5B,YACC,qBAAqB,OAClB,UAAU,WAAW,KACrB,IAAI,KAAK,WAAW,WAAW;QACzC;IACF;AACF;AAMO,eAAe,YAAY,KAAa;IAC7C,MAAM,YAAY,MAAM,IAAA,0IAAgB;IACxC,MAAM,iBAAiB,MAAM,IAAA,8IAAoB,EAAW,WAAW;IAEvE,MAAM,MAAM,MAAM,eAAe,OAAO,CAAC;QAAE,IAAI;IAAM;IAErD,IAAI,CAAC,KAAK,OAAO;IAEjB,6CAA6C;IAC7C,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG,SAAS,GAAG;IACvC,OAAO;QACL,GAAG,OAAO;QACV,WAAW,OAAO,cAAc,WAC5B,YACC,qBAAqB,OAClB,UAAU,WAAW,KACrB,IAAI,KAAK,WAAW,WAAW;IACzC;AACF;;;IA5HsB;IA2BA;IAmDA;IA4BA;;AA1GA,+OAAA;AA2BA,+OAAA;AAmDA,+OAAA;AA4BA,+OAAA"}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/auth/authServer.ts"],"sourcesContent":["\"use server\"\n\nimport { redirect } from \"next/navigation\"\nimport { getCompanyCollection } from \"@/lib/db/companyDb\"\nimport { getCompaniesCollection } from \"@/lib/db/companyDb\"\nimport { setSession, setCompanySession, setWorkerInSession } from \"./session\"\n\ninterface WorkerWithPassword {\n  id: string\n  name: string\n  role: string\n  avatarColor: string\n  companyId: string\n  password?: string\n}\n\nexport interface LoginResult {\n  success: boolean\n  error?: string\n  redirect?: string\n}\n\n/**\n * Login company - verifies company password\n * Sets session with companyId only (worker not selected yet)\n */\nexport async function loginCompany(\n  companyId: string,\n  password: string\n): Promise<LoginResult> {\n  try {\n    // Get company from shared companies collection\n    const companiesCollection = await getCompaniesCollection()\n    const company = await companiesCollection.findOne({ companyId })\n\n    // Verify company exists\n    if (!company) {\n      return {\n        success: false,\n        error: \"Company not found\",\n      }\n    }\n\n    // Verify password\n    // In production, passwords should be hashed (e.g., using bcrypt)\n    const correctPassword = (company as any).password\n\n    if (!correctPassword || correctPassword !== password) {\n      return {\n        success: false,\n        error: \"Incorrect password\",\n      }\n    }\n\n    // Set session with companyId only (partial session)\n    await setCompanySession(companyId)\n\n    return {\n      success: true,\n    }\n  } catch (error) {\n    console.error(\"Company login error:\", error)\n    return {\n      success: false,\n      error: \"An error occurred during login\",\n    }\n  }\n}\n\n/**\n * Select worker - sets workerId in existing company session\n * No password required (company already authenticated)\n */\nexport async function selectWorker(\n  companyId: string,\n  workerId: string\n): Promise<LoginResult> {\n  try {\n    // Get company-scoped workers collection\n    const workersCollection = await getCompanyCollection<WorkerWithPassword>(\n      companyId,\n      \"workers\"\n    )\n\n    // Find the worker in the company's collection\n    const worker = await workersCollection.findOne({ id: workerId })\n\n    // Verify worker exists and belongs to the company\n    if (!worker) {\n      return {\n        success: false,\n        error: \"Worker not found\",\n      }\n    }\n\n    if (worker.companyId !== companyId) {\n      return {\n        success: false,\n        error: \"Worker does not belong to this company\",\n      }\n    }\n\n    // Set workerId in existing company session\n    await setWorkerInSession(workerId)\n\n    // Record login session in company's sessions collection\n    const sessionsCollection = await getCompanyCollection(companyId, \"sessions\")\n    await sessionsCollection.insertOne({\n      workerId,\n      companyId,\n      loginAt: new Date(),\n      createdAt: new Date(),\n    })\n\n    // Redirect to dashboard (this will throw, which is expected in Next.js)\n    redirect(\"/\")\n  } catch (error) {\n    // If it's a redirect error, let it propagate\n    if (error && typeof error === \"object\" && \"digest\" in error) {\n      throw error\n    }\n\n    console.error(\"Worker selection error:\", error)\n    return {\n      success: false,\n      error: \"An error occurred during worker selection\",\n    }\n  }\n}\n\n/**\n * Legacy: Login worker - verifies credentials against company-scoped worker collection\n * Sets session with companyId and workerId on success\n * @deprecated Use loginCompany + selectWorker instead\n */\nexport async function loginWorker(\n  companyId: string,\n  workerId: string,\n  password: string\n): Promise<LoginResult> {\n  try {\n    // Get company-scoped workers collection\n    const workersCollection = await getCompanyCollection<WorkerWithPassword>(\n      companyId,\n      \"workers\"\n    )\n\n    // Find the worker in the company's collection\n    const worker = await workersCollection.findOne({ id: workerId })\n\n    // Verify worker exists and belongs to the company\n    if (!worker) {\n      return {\n        success: false,\n        error: \"Worker not found\",\n      }\n    }\n\n    if (worker.companyId !== companyId) {\n      return {\n        success: false,\n        error: \"Worker does not belong to this company\",\n      }\n    }\n\n    // Verify password\n    // In production, passwords should be hashed (e.g., using bcrypt)\n    const correctPassword = worker.password\n\n    if (!correctPassword || correctPassword !== password) {\n      return {\n        success: false,\n        error: \"Incorrect password\",\n      }\n    }\n\n    // Set session with companyId and workerId\n    await setSession(companyId, workerId)\n\n    // Record login session in company's sessions collection\n    const sessionsCollection = await getCompanyCollection(companyId, \"sessions\")\n    await sessionsCollection.insertOne({\n      workerId,\n      companyId,\n      loginAt: new Date(),\n      createdAt: new Date(),\n    })\n\n    // Redirect to dashboard (this will throw, which is expected in Next.js)\n    redirect(\"/\")\n  } catch (error) {\n    // If it's a redirect error, let it propagate\n    if (error && typeof error === \"object\" && \"digest\" in error) {\n      throw error\n    }\n\n    console.error(\"Login error:\", error)\n    return {\n      success: false,\n      error: \"An error occurred during login\",\n    }\n  }\n}\n\nexport async function logout(): Promise<void> {\n  const { clearSession } = await import(\"./session\")\n  \n  // Clear session cookies\n  await clearSession()\n  \n  // In a real app, you would also:\n  // 1. Invalidate session in database\n  // 2. Log logout event\n  \n  // Redirect to login page\n  redirect(\"/login\")\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 637, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getTruckLogs as '003823d3910066eeba55100ec7665dcabbb8bf509e'} from 'ACTIONS_MODULE0'\nexport {saveTruckLog as '40d4e21626266eb13b2afb47fa55c2fcffae3980c2'} from 'ACTIONS_MODULE0'\nexport {sendTruckLogToCustoms as '40a2ead62e15f1c40ce6d586420a2c191a6a5596a9'} from 'ACTIONS_MODULE0'\nexport {logout as '00db69d86cc3b8562947f5f5012a7dc7936b0621ed'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AAGA"}}]
}