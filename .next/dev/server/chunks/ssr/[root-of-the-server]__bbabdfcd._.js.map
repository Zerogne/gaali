{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/db/client.ts"],"sourcesContent":["import { MongoClient, Db } from \"mongodb\"\n\nif (!process.env.MONGODB_URI) {\n  throw new Error('Invalid/Missing environment variable: \"MONGODB_URI\"')\n}\n\nconst uri = process.env.MONGODB_URI\nconst options = {}\n\nlet client: MongoClient\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development mode, use a global variable so that the value\n  // is preserved across module reloads caused by HMR (Hot Module Replacement).\n  let globalWithMongo = global as typeof globalThis & {\n    _mongoClientPromise?: Promise<MongoClient>\n  }\n\n  if (!globalWithMongo._mongoClientPromise) {\n    client = new MongoClient(uri, options)\n    globalWithMongo._mongoClientPromise = client.connect()\n  }\n  clientPromise = globalWithMongo._mongoClientPromise\n} else {\n  // In production mode, it's best to not use a global variable.\n  client = new MongoClient(uri, options)\n  clientPromise = client.connect()\n}\n\n// Export a module-scoped MongoClient promise. By doing this in a\n// separate module, the client can be shared across functions.\nexport default clientPromise\n\n/**\n * Get the main database instance\n */\nexport async function getDatabase(): Promise<Db> {\n  const client = await clientPromise\n  return client.db(process.env.MONGODB_DB_NAME || \"truck-weighing-dashboard\")\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,WAAW,EAAE;IAC5B,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,MAAM,UAAU,CAAC;AAEjB,IAAI;AACJ,IAAI;AAEJ,wCAA4C;IAC1C,+DAA+D;IAC/D,6EAA6E;IAC7E,IAAI;IAIJ,IAAI,CAAC,gBAAgB,mBAAmB,EAAE;QACxC,SAAS,IAAI,sHAAW,CAAC,KAAK;QAC9B,gBAAgB,mBAAmB,GAAG,OAAO,OAAO;IACtD;IACA,gBAAgB,gBAAgB,mBAAmB;AACrD;;uCAQe;AAKR,eAAe;IACpB,MAAM,SAAS,MAAM;IACrB,OAAO,OAAO,EAAE,CAAC,QAAQ,GAAG,CAAC,eAAe,IAAI;AAClD"}},
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/db/companyDb.ts"],"sourcesContent":["import { Collection, Db } from \"mongodb\"\nimport { getDatabase } from \"./client\"\n\n/**\n * Get a company-scoped collection.\n * This is the ONLY method that should be used to access company data.\n * \n * Pattern: company_{companyId}_{collectionName}\n * \n * Examples:\n * - company_altan-logistics_logs\n * - company_altan-logistics_workers\n * - company_altan-logistics_sessions\n * \n * @param companyId - The company identifier\n * @param collectionName - The collection name (e.g., 'logs', 'workers', 'sessions')\n * @returns MongoDB Collection instance scoped to the company\n */\nexport async function getCompanyCollection<T = any>(\n  companyId: string,\n  collectionName: string\n): Promise<Collection<T & any>> {\n  if (!companyId || !collectionName) {\n    throw new Error(\"companyId and collectionName are required\")\n  }\n\n  const db = await getDatabase()\n  const collectionNameWithPrefix = `company_${companyId}_${collectionName}`\n  \n  return db.collection<T & any>(collectionNameWithPrefix)\n}\n\n/**\n * Get the company database instance (for operations that need the DB object)\n * @param companyId - The company identifier\n * @returns MongoDB Db instance\n */\nexport async function getCompanyDB(companyId: string): Promise<Db> {\n  if (!companyId) {\n    throw new Error(\"companyId is required\")\n  }\n  \n  return getDatabase()\n}\n\n/**\n * Get the global companies metadata collection\n * This is the ONLY shared collection across all companies\n */\nexport async function getCompaniesCollection() {\n  const db = await getDatabase()\n  return db.collection(\"companies\")\n}\n\n/**\n * Ensure company collections exist (optional helper for initialization)\n * Creates indexes for better query performance\n */\nexport async function ensureCompanyCollections(companyId: string) {\n  const collections = [\"logs\", \"workers\", \"sessions\", \"settings\", \"products\"]\n  \n  for (const collectionName of collections) {\n    const collection = await getCompanyCollection(companyId, collectionName)\n    \n    // Create indexes for common queries\n    if (collectionName === \"logs\") {\n      await collection.createIndex({ createdAt: -1 })\n      await collection.createIndex({ direction: 1 })\n      await collection.createIndex({ sentToCustoms: 1 })\n      await collection.createIndex({ plate: 1 })\n    } else if (collectionName === \"workers\") {\n      await collection.createIndex({ companyId: 1 })\n      await collection.createIndex({ id: 1 }, { unique: true })\n    } else if (collectionName === \"sessions\") {\n      await collection.createIndex({ workerId: 1 })\n      await collection.createIndex({ createdAt: -1 })\n    } else if (collectionName === \"products\") {\n      await collection.createIndex({ value: 1 }, { unique: true })\n      await collection.createIndex({ isCustom: 1 })\n    }\n  }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AACA;;AAiBO,eAAe,qBACpB,SAAiB,EACjB,cAAsB;IAEtB,IAAI,CAAC,aAAa,CAAC,gBAAgB;QACjC,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,KAAK,MAAM,IAAA,kIAAW;IAC5B,MAAM,2BAA2B,CAAC,QAAQ,EAAE,UAAU,CAAC,EAAE,gBAAgB;IAEzE,OAAO,GAAG,UAAU,CAAU;AAChC;AAOO,eAAe,aAAa,SAAiB;IAClD,IAAI,CAAC,WAAW;QACd,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAA,kIAAW;AACpB;AAMO,eAAe;IACpB,MAAM,KAAK,MAAM,IAAA,kIAAW;IAC5B,OAAO,GAAG,UAAU,CAAC;AACvB;AAMO,eAAe,yBAAyB,SAAiB;IAC9D,MAAM,cAAc;QAAC;QAAQ;QAAW;QAAY;QAAY;KAAW;IAE3E,KAAK,MAAM,kBAAkB,YAAa;QACxC,MAAM,aAAa,MAAM,qBAAqB,WAAW;QAEzD,oCAAoC;QACpC,IAAI,mBAAmB,QAAQ;YAC7B,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW,CAAC;YAAE;YAC7C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC5C,MAAM,WAAW,WAAW,CAAC;gBAAE,eAAe;YAAE;YAChD,MAAM,WAAW,WAAW,CAAC;gBAAE,OAAO;YAAE;QAC1C,OAAO,IAAI,mBAAmB,WAAW;YACvC,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW;YAAE;YAC5C,MAAM,WAAW,WAAW,CAAC;gBAAE,IAAI;YAAE,GAAG;gBAAE,QAAQ;YAAK;QACzD,OAAO,IAAI,mBAAmB,YAAY;YACxC,MAAM,WAAW,WAAW,CAAC;gBAAE,UAAU;YAAE;YAC3C,MAAM,WAAW,WAAW,CAAC;gBAAE,WAAW,CAAC;YAAE;QAC/C,OAAO,IAAI,mBAAmB,YAAY;YACxC,MAAM,WAAW,WAAW,CAAC;gBAAE,OAAO;YAAE,GAAG;gBAAE,QAAQ;YAAK;YAC1D,MAAM,WAAW,WAAW,CAAC;gBAAE,UAAU;YAAE;QAC7C;IACF;AACF"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/auth/session.ts"],"sourcesContent":["\"use server\"\n\nimport { cookies } from \"next/headers\"\nimport { redirect } from \"next/navigation\"\n\nconst COMPANY_ID_COOKIE = \"company-id\"\nconst WORKER_ID_COOKIE = \"worker-id\"\nconst SESSION_EXPIRES_COOKIE = \"session-expires\"\n\n// Session duration: 7 days (in seconds)\nconst SESSION_MAX_AGE = 60 * 60 * 24 * 7\n\n// Check if cookies should be secure (production or forced)\nconst isSecure = process.env.NODE_ENV === \"production\" || process.env.FORCE_SECURE_COOKIES === \"true\"\n\nexport interface SessionData {\n  companyId: string\n  workerId: string\n  expiresAt: number\n}\n\n/**\n * Get the active company context from session\n * Throws if no company is set (forces login)\n * Validates session expiration\n */\nexport async function getActiveCompany(): Promise<string> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId) {\n    redirect(\"/login\")\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      // Session expired, clear and redirect\n      await clearSession()\n      redirect(\"/login\")\n    }\n  }\n\n  return companyId\n}\n\n/**\n * Get the current session data (companyId + workerId)\n * Returns null if not authenticated or expired\n */\nexport async function getSession(): Promise<SessionData | null> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const workerId = cookieStore.get(WORKER_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId || !workerId) {\n    return null\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      // Session expired\n      await clearSession()\n      return null\n    }\n  }\n\n  return {\n    companyId,\n    workerId,\n    expiresAt: expiresAt ? parseInt(expiresAt, 10) : Date.now() + SESSION_MAX_AGE * 1000,\n  }\n}\n\n/**\n * Set session expiration timestamp\n */\nfunction setSessionExpiration(cookieStore: ReturnType<typeof cookies>) {\n  const expiresAt = Date.now() + SESSION_MAX_AGE * 1000\n  cookieStore.set(SESSION_EXPIRES_COOKIE, expiresAt.toString(), {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n}\n\n/**\n * Set session after successful login\n * Includes expiration timestamp\n */\nexport async function setSession(companyId: string, workerId: string) {\n  const cookieStore = await cookies()\n  \n  // Validate inputs\n  if (!companyId || !workerId) {\n    throw new Error(\"Company ID and Worker ID are required\")\n  }\n\n  // Set cookies with httpOnly for security\n  cookieStore.set(COMPANY_ID_COOKIE, companyId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  cookieStore.set(WORKER_ID_COOKIE, workerId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Set company session (partial session - company logged in, worker not selected yet)\n * Includes expiration timestamp\n */\nexport async function setCompanySession(companyId: string) {\n  const cookieStore = await cookies()\n  \n  if (!companyId) {\n    throw new Error(\"Company ID is required\")\n  }\n\n  cookieStore.set(COMPANY_ID_COOKIE, companyId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Set worker ID in existing company session\n * Refreshes expiration\n */\nexport async function setWorkerInSession(workerId: string) {\n  const cookieStore = await cookies()\n  \n  if (!workerId) {\n    throw new Error(\"Worker ID is required\")\n  }\n\n  // Verify company session exists\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  if (!companyId) {\n    throw new Error(\"Company session not found\")\n  }\n\n  cookieStore.set(WORKER_ID_COOKIE, workerId, {\n    httpOnly: true,\n    secure: isSecure,\n    sameSite: \"lax\",\n    maxAge: SESSION_MAX_AGE,\n    path: \"/\",\n  })\n\n  setSessionExpiration(cookieStore)\n}\n\n/**\n * Refresh session expiration\n */\nexport async function refreshSession() {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const workerId = cookieStore.get(WORKER_ID_COOKIE)?.value\n\n  if (companyId && workerId) {\n    setSessionExpiration(cookieStore)\n  }\n}\n\n/**\n * Clear session on logout\n */\nexport async function clearSession() {\n  const cookieStore = await cookies()\n  cookieStore.delete(COMPANY_ID_COOKIE)\n  cookieStore.delete(WORKER_ID_COOKIE)\n  cookieStore.delete(SESSION_EXPIRES_COOKIE)\n}\n\n/**\n * Check if user is authenticated (both company and worker)\n * Also checks expiration\n */\nexport async function isAuthenticated(): Promise<boolean> {\n  const session = await getSession()\n  return session !== null\n}\n\n/**\n * Check if company is logged in (partial authentication)\n * Also checks expiration\n */\nexport async function isCompanyAuthenticated(): Promise<boolean> {\n  const cookieStore = await cookies()\n  const companyId = cookieStore.get(COMPANY_ID_COOKIE)?.value\n  const expiresAt = cookieStore.get(SESSION_EXPIRES_COOKIE)?.value\n\n  if (!companyId) {\n    return false\n  }\n\n  // Check expiration\n  if (expiresAt) {\n    const expires = parseInt(expiresAt, 10)\n    if (isNaN(expires) || expires < Date.now()) {\n      return false\n    }\n  }\n\n  return true\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/validation.ts"],"sourcesContent":["/**\n * Zod validation schemas for all API inputs\n * Ensures type safety and prevents injection attacks\n */\nimport { z } from 'zod'\n\n// Company login validation\nexport const loginCompanySchema = z.object({\n  companyId: z\n    .string()\n    .min(1, 'Company ID is required')\n    .max(100, 'Company ID is too long')\n    .regex(/^[a-z0-9-]+$/, 'Company ID contains invalid characters'),\n  password: z\n    .string()\n    .min(1, 'Password is required')\n    .max(200, 'Password is too long'),\n})\n\nexport type LoginCompanyInput = z.infer<typeof loginCompanySchema>\n\n// Worker selection validation\nexport const selectWorkerSchema = z.object({\n  workerId: z\n    .string()\n    .min(1, 'Worker ID is required')\n    .max(100, 'Worker ID is too long')\n    .regex(/^[a-z0-9-]+$/, 'Worker ID contains invalid characters'),\n})\n\nexport type SelectWorkerInput = z.infer<typeof selectWorkerSchema>\n\n// Legacy worker login (deprecated but still used)\nexport const loginWorkerSchema = z.object({\n  companyId: z\n    .string()\n    .min(1, 'Company ID is required')\n    .max(100, 'Company ID is too long')\n    .regex(/^[a-z0-9-]+$/, 'Company ID contains invalid characters'),\n  workerId: z\n    .string()\n    .min(1, 'Worker ID is required')\n    .max(100, 'Worker ID is too long')\n    .regex(/^[a-z0-9-]+$/, 'Worker ID contains invalid characters'),\n  password: z\n    .string()\n    .min(1, 'Password is required')\n    .max(200, 'Password is too long'),\n})\n\nexport type LoginWorkerInput = z.infer<typeof loginWorkerSchema>\n\n// Truck log validation\nexport const truckLogSchema = z.object({\n  direction: z.enum(['IN', 'OUT'], {\n    errorMap: () => ({ message: 'Direction must be IN or OUT' }),\n  }),\n  plate: z\n    .string()\n    .min(1, 'Plate number is required')\n    .max(20, 'Plate number is too long')\n    .regex(/^[А-ЯЁA-Z0-9\\s-]+$/i, 'Plate number contains invalid characters'),\n  driverId: z.string().max(100).optional(),\n  driverName: z\n    .string()\n    .min(1, 'Driver name is required')\n    .max(200, 'Driver name is too long'),\n  cargoType: z\n    .string()\n    .min(1, 'Cargo type is required')\n    .max(100, 'Cargo type is too long'),\n  weightKg: z\n    .number()\n    .positive('Weight must be positive')\n    .max(1000000, 'Weight is too large')\n    .optional(),\n  netWeightKg: z\n    .number()\n    .positive('Net weight must be positive')\n    .max(1000000, 'Net weight is too large')\n    .optional(),\n  comments: z.string().max(1000, 'Comments are too long').optional(),\n  vehicleRegistrationNumber: z.string().max(50).optional(),\n  vehicleRegistrationYear: z.string().max(4).optional(),\n  origin: z.string().max(200).optional(),\n  destination: z.string().max(200).optional(),\n  senderOrganizationId: z.string().max(100).optional(),\n  senderOrganization: z.string().max(200).optional(),\n  receiverOrganizationId: z.string().max(100).optional(),\n  receiverOrganization: z.string().max(200).optional(),\n  transportCompanyId: z.string().max(100).optional(),\n  transportType: z.enum(['truck', 'container', 'tanker', 'flatbed', 'refrigerated', 'other']).optional(),\n  sealNumber: z.string().max(100).optional(),\n  hasTrailer: z.boolean().optional(),\n  trailerPlate: z.string().max(20).optional(),\n})\n\nexport type TruckLogInput = z.infer<typeof truckLogSchema>\n\n// Product validation\nexport const addProductSchema = z.object({\n  label: z\n    .string()\n    .min(1, 'Product label is required')\n    .max(200, 'Product label is too long')\n    .trim(),\n})\n\nexport type AddProductInput = z.infer<typeof addProductSchema>\n\n// Pagination validation\nexport const paginationSchema = z.object({\n  page: z.coerce.number().int().positive().default(1),\n  limit: z.coerce.number().int().positive().max(100).default(50),\n})\n\nexport type PaginationInput = z.infer<typeof paginationSchema>\n\n// Delete product validation\nexport const deleteProductSchema = z.object({\n  id: z\n    .string()\n    .min(1, 'Product ID is required')\n    .max(100, 'Product ID is too long'),\n})\n\nexport type DeleteProductInput = z.infer<typeof deleteProductSchema>\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 424, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/rateLimit.ts"],"sourcesContent":["/**\n * In-memory rate limiting for login endpoints\n * For production, consider upgrading to Redis-based solution (Upstash)\n */\n\ninterface RateLimitEntry {\n  count: number\n  resetAt: number\n}\n\n// In-memory store (clears on server restart)\n// In production, use Redis or similar\nconst rateLimitStore = new Map<string, RateLimitEntry>()\n\n// Cleanup old entries every 5 minutes\nif (typeof setInterval !== 'undefined') {\n  setInterval(() => {\n    const now = Date.now()\n    for (const [key, entry] of rateLimitStore.entries()) {\n      if (entry.resetAt < now) {\n        rateLimitStore.delete(key)\n      }\n    }\n  }, 5 * 60 * 1000)\n}\n\nexport interface RateLimitResult {\n  success: boolean\n  limit: number\n  remaining: number\n  resetAt: number\n}\n\n/**\n * Rate limit by identifier (e.g., IP address or companyId)\n * @param identifier - Unique identifier for rate limiting\n * @param maxAttempts - Maximum attempts allowed\n * @param windowMs - Time window in milliseconds\n */\nexport async function rateLimit(\n  identifier: string,\n  maxAttempts: number = 5,\n  windowMs: number = 15 * 60 * 1000 // 15 minutes\n): Promise<RateLimitResult> {\n  const now = Date.now()\n  const entry = rateLimitStore.get(identifier)\n\n  // No entry or expired\n  if (!entry || entry.resetAt < now) {\n    const newEntry: RateLimitEntry = {\n      count: 1,\n      resetAt: now + windowMs,\n    }\n    rateLimitStore.set(identifier, newEntry)\n    return {\n      success: true,\n      limit: maxAttempts,\n      remaining: maxAttempts - 1,\n      resetAt: newEntry.resetAt,\n    }\n  }\n\n  // Entry exists and not expired\n  if (entry.count >= maxAttempts) {\n    return {\n      success: false,\n      limit: maxAttempts,\n      remaining: 0,\n      resetAt: entry.resetAt,\n    }\n  }\n\n  // Increment count\n  entry.count++\n  rateLimitStore.set(identifier, entry)\n\n  return {\n    success: true,\n    limit: maxAttempts,\n    remaining: maxAttempts - entry.count,\n    resetAt: entry.resetAt,\n  }\n}\n\n/**\n * Get client IP from request headers\n * Used for rate limiting by IP\n */\nexport function getClientIP(request?: Request): string {\n  if (!request) return 'unknown'\n\n  // Check various headers (in order of preference)\n  const forwarded = request.headers.get('x-forwarded-for')\n  if (forwarded) {\n    return forwarded.split(',')[0].trim()\n  }\n\n  const realIP = request.headers.get('x-real-ip')\n  if (realIP) {\n    return realIP\n  }\n\n  return 'unknown'\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAOD,6CAA6C;AAC7C,sCAAsC;AACtC,MAAM,iBAAiB,IAAI;AAE3B,sCAAsC;AACtC,IAAI,OAAO,gBAAgB,aAAa;IACtC,YAAY;QACV,MAAM,MAAM,KAAK,GAAG;QACpB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,eAAe,OAAO,GAAI;YACnD,IAAI,MAAM,OAAO,GAAG,KAAK;gBACvB,eAAe,MAAM,CAAC;YACxB;QACF;IACF,GAAG,IAAI,KAAK;AACd;AAeO,eAAe,UACpB,UAAkB,EAClB,cAAsB,CAAC,EACvB,WAAmB,KAAK,KAAK,KAAK,aAAa;AAAd;IAEjC,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,QAAQ,eAAe,GAAG,CAAC;IAEjC,sBAAsB;IACtB,IAAI,CAAC,SAAS,MAAM,OAAO,GAAG,KAAK;QACjC,MAAM,WAA2B;YAC/B,OAAO;YACP,SAAS,MAAM;QACjB;QACA,eAAe,GAAG,CAAC,YAAY;QAC/B,OAAO;YACL,SAAS;YACT,OAAO;YACP,WAAW,cAAc;YACzB,SAAS,SAAS,OAAO;QAC3B;IACF;IAEA,+BAA+B;IAC/B,IAAI,MAAM,KAAK,IAAI,aAAa;QAC9B,OAAO;YACL,SAAS;YACT,OAAO;YACP,WAAW;YACX,SAAS,MAAM,OAAO;QACxB;IACF;IAEA,kBAAkB;IAClB,MAAM,KAAK;IACX,eAAe,GAAG,CAAC,YAAY;IAE/B,OAAO;QACL,SAAS;QACT,OAAO;QACP,WAAW,cAAc,MAAM,KAAK;QACpC,SAAS,MAAM,OAAO;IACxB;AACF;AAMO,SAAS,YAAY,OAAiB;IAC3C,IAAI,CAAC,SAAS,OAAO;IAErB,iDAAiD;IACjD,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC;IACtC,IAAI,WAAW;QACb,OAAO,UAAU,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI;IACrC;IAEA,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,IAAI,QAAQ;QACV,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 501, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/errors.ts"],"sourcesContent":["/**\n * Centralized error handling utilities\n * Provides consistent error types and handling across the application\n */\n\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public statusCode: number = 500,\n    public isOperational: boolean = true\n  ) {\n    super(message)\n    this.name = 'AppError'\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string, public fields?: Record<string, string>) {\n    super(message, 'VALIDATION_ERROR', 400, true)\n    this.name = 'ValidationError'\n  }\n}\n\nexport class AuthenticationError extends AppError {\n  constructor(message: string = 'Authentication required') {\n    super(message, 'AUTHENTICATION_ERROR', 401, true)\n    this.name = 'AuthenticationError'\n  }\n}\n\nexport class AuthorizationError extends AppError {\n  constructor(message: string = 'Insufficient permissions') {\n    super(message, 'AUTHORIZATION_ERROR', 403, true)\n    this.name = 'AuthorizationError'\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(message: string = 'Resource not found') {\n    super(message, 'NOT_FOUND', 404, true)\n    this.name = 'NotFoundError'\n  }\n}\n\nexport class RateLimitError extends AppError {\n  constructor(message: string = 'Too many requests', public retryAfter?: number) {\n    super(message, 'RATE_LIMIT_ERROR', 429, true)\n    this.name = 'RateLimitError'\n  }\n}\n\n/**\n * Handle errors and return user-friendly messages\n * Never expose internal error details in production\n */\nexport function handleError(error: unknown): { message: string; code: string; statusCode: number } {\n  // Known operational errors\n  if (error instanceof AppError) {\n    return {\n      message: error.message,\n      code: error.code,\n      statusCode: error.statusCode,\n    }\n  }\n\n  // Validation errors from Zod\n  if (error && typeof error === 'object' && 'issues' in error) {\n    const zodError = error as { issues: Array<{ path: string[]; message: string }> }\n    const messages = zodError.issues.map((issue) => issue.message).join(', ')\n    return {\n      message: `Validation failed: ${messages}`,\n      code: 'VALIDATION_ERROR',\n      statusCode: 400,\n    }\n  }\n\n  // Standard Error objects\n  if (error instanceof Error) {\n    // Log full error in development, but don't expose to user\n    if (process.env.NODE_ENV === 'development') {\n      console.error('Error details:', error)\n    }\n    return {\n      message: process.env.NODE_ENV === 'production'\n        ? 'An error occurred. Please try again.'\n        : error.message,\n      code: 'INTERNAL_ERROR',\n      statusCode: 500,\n    }\n  }\n\n  // Unknown error types\n  console.error('Unknown error type:', error)\n  return {\n    message: process.env.NODE_ENV === 'production'\n      ? 'An unexpected error occurred'\n      : String(error),\n    code: 'UNKNOWN_ERROR',\n    statusCode: 500,\n  }\n}\n\n/**\n * Convert error to JSON response format\n */\nexport function errorToResponse(error: unknown) {\n  const handled = handleError(error)\n  return {\n    error: handled.message,\n    code: handled.code,\n    ...(process.env.NODE_ENV === 'development' && error instanceof Error\n      ? { stack: error.stack }\n      : {}),\n  }\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;AAEM,MAAM,iBAAiB;;;;IAC5B,YACE,OAAe,EACf,AAAO,IAAY,EACnB,AAAO,aAAqB,GAAG,EAC/B,AAAO,gBAAyB,IAAI,CACpC;QACA,KAAK,CAAC,eAJC,OAAA,WACA,aAAA,iBACA,gBAAA;QAGP,IAAI,CAAC,IAAI,GAAG;QACZ,MAAM,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW;IAChD;AACF;AAEO,MAAM,wBAAwB;;IACnC,YAAY,OAAe,EAAE,AAAO,MAA+B,CAAE;QACnE,KAAK,CAAC,SAAS,oBAAoB,KAAK,YADN,SAAA;QAElC,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,4BAA4B;IACvC,YAAY,UAAkB,yBAAyB,CAAE;QACvD,KAAK,CAAC,SAAS,wBAAwB,KAAK;QAC5C,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,2BAA2B;IACtC,YAAY,UAAkB,0BAA0B,CAAE;QACxD,KAAK,CAAC,SAAS,uBAAuB,KAAK;QAC3C,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,sBAAsB;IACjC,YAAY,UAAkB,oBAAoB,CAAE;QAClD,KAAK,CAAC,SAAS,aAAa,KAAK;QACjC,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAEO,MAAM,uBAAuB;;IAClC,YAAY,UAAkB,mBAAmB,EAAE,AAAO,UAAmB,CAAE;QAC7E,KAAK,CAAC,SAAS,oBAAoB,KAAK,YADgB,aAAA;QAExD,IAAI,CAAC,IAAI,GAAG;IACd;AACF;AAMO,SAAS,YAAY,KAAc;IACxC,2BAA2B;IAC3B,IAAI,iBAAiB,UAAU;QAC7B,OAAO;YACL,SAAS,MAAM,OAAO;YACtB,MAAM,MAAM,IAAI;YAChB,YAAY,MAAM,UAAU;QAC9B;IACF;IAEA,6BAA6B;IAC7B,IAAI,SAAS,OAAO,UAAU,YAAY,YAAY,OAAO;QAC3D,MAAM,WAAW;QACjB,MAAM,WAAW,SAAS,MAAM,CAAC,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;QACpE,OAAO;YACL,SAAS,CAAC,mBAAmB,EAAE,UAAU;YACzC,MAAM;YACN,YAAY;QACd;IACF;IAEA,yBAAyB;IACzB,IAAI,iBAAiB,OAAO;QAC1B,0DAA0D;QAC1D,wCAA4C;YAC1C,QAAQ,KAAK,CAAC,kBAAkB;QAClC;QACA,OAAO;YACL,SAAS,sCACL,0BACA,MAAM,OAAO;YACjB,MAAM;YACN,YAAY;QACd;IACF;IAEA,sBAAsB;IACtB,QAAQ,KAAK,CAAC,uBAAuB;IACrC,OAAO;QACL,SAAS,sCACL,0BACA,OAAO;QACX,MAAM;QACN,YAAY;IACd;AACF;AAKO,SAAS,gBAAgB,KAAc;IAC5C,MAAM,UAAU,YAAY;IAC5B,OAAO;QACL,OAAO,QAAQ,OAAO;QACtB,MAAM,QAAQ,IAAI;QAClB,GAAI,oDAAyB,iBAAiB,iBAAiB,QAC3D;YAAE,OAAO,MAAM,KAAK;QAAC,IACrB,CAAC,CAAC;IACR;AACF"}},
    {"offset": {"line": 617, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/lib/auth/authServer.ts"],"sourcesContent":["\"use server\"\n\nimport { redirect } from \"next/navigation\"\nimport { headers } from \"next/headers\"\nimport bcrypt from \"bcryptjs\"\nimport { getCompanyCollection } from \"@/lib/db/companyDb\"\nimport { getCompaniesCollection } from \"@/lib/db/companyDb\"\nimport { setSession, setCompanySession, setWorkerInSession, getActiveCompany } from \"./session\"\nimport { loginCompanySchema, selectWorkerSchema, loginWorkerSchema } from \"@/lib/validation\"\nimport { rateLimit } from \"@/lib/rateLimit\"\nimport { handleError } from \"@/lib/errors\"\n\ninterface WorkerWithPassword {\n  id: string\n  name: string\n  role: string\n  avatarColor: string\n  companyId: string\n  password?: string\n}\n\nexport interface LoginResult {\n  success: boolean\n  error?: string\n  redirect?: string\n}\n\n/**\n * Login company - verifies company password with bcrypt\n * Sets session with companyId only (worker not selected yet)\n * Includes rate limiting and input validation\n */\nexport async function loginCompany(\n  companyId: string,\n  password: string\n): Promise<LoginResult> {\n  try {\n    // Validate input with Zod\n    const validation = loginCompanySchema.safeParse({ companyId, password })\n    if (!validation.success) {\n      return {\n        success: false,\n        error: \"Invalid input. Please check your credentials.\",\n      }\n    }\n\n    // Rate limiting - get IP from headers\n    const headersList = await headers()\n    const forwardedFor = headersList.get('x-forwarded-for')\n    const realIP = headersList.get('x-real-ip')\n    const clientIP = forwardedFor?.split(',')[0]?.trim() || realIP || 'unknown'\n    const rateLimitId = `login:company:${companyId}:${clientIP}`\n    const rateLimitResult = await rateLimit(rateLimitId, 5, 15 * 60 * 1000) // 5 attempts per 15 minutes\n\n    if (!rateLimitResult.success) {\n      const retryAfter = Math.ceil((rateLimitResult.resetAt - Date.now()) / 1000)\n      return {\n        success: false,\n        error: `Too many login attempts. Please try again in ${retryAfter} seconds.`,\n      }\n    }\n\n    // Get company from shared companies collection\n    const companiesCollection = await getCompaniesCollection()\n    const company = await companiesCollection.findOne({ companyId })\n\n    // Use generic error message to prevent enumeration\n    if (!company) {\n      console.error(`Company not found: ${companyId}`)\n      return {\n        success: false,\n        error: \"Invalid credentials\",\n      }\n    }\n\n    if (!company.password) {\n      console.error(`Company found but no password set: ${companyId}`)\n      return {\n        success: false,\n        error: \"Invalid credentials\",\n      }\n    }\n\n    // Verify password with bcrypt\n    const isValid = await bcrypt.compare(password, company.password)\n    if (!isValid) {\n      console.error(`Password mismatch for company: ${companyId}`)\n      return {\n        success: false,\n        error: \"Invalid credentials\",\n      }\n    }\n\n    // Set session with companyId only (partial session)\n    await setCompanySession(companyId)\n\n    return {\n      success: true,\n    }\n  } catch (error) {\n    const handled = handleError(error)\n    return {\n      success: false,\n      error: handled.message,\n    }\n  }\n}\n\n/**\n * Select worker - sets workerId in existing company session\n * No password required (company already authenticated)\n * SECURITY: companyId is retrieved from session, NOT from client\n */\nexport async function selectWorker(\n  workerId: string\n): Promise<LoginResult> {\n  try {\n    // Validate input\n    const validation = selectWorkerSchema.safeParse({ workerId })\n    if (!validation.success) {\n      return {\n        success: false,\n        error: \"Invalid worker ID\",\n      }\n    }\n\n    // CRITICAL: Get companyId from session, not from client\n    const sessionCompanyId = await getActiveCompany()\n\n    // Get company-scoped workers collection using session companyId\n    const workersCollection = await getCompanyCollection<WorkerWithPassword>(\n      sessionCompanyId,\n      \"workers\"\n    )\n\n    // Find the worker in the company's collection\n    const worker = await workersCollection.findOne({ id: workerId })\n\n    // Verify worker exists and belongs to the session company\n    if (!worker || worker.companyId !== sessionCompanyId) {\n      return {\n        success: false,\n        error: \"Worker not found\",\n      }\n    }\n\n    // Set workerId in existing company session\n    await setWorkerInSession(workerId)\n\n    // Record login session in company's sessions collection\n    const sessionsCollection = await getCompanyCollection(sessionCompanyId, \"sessions\")\n    await sessionsCollection.insertOne({\n      workerId,\n      companyId: sessionCompanyId,\n      loginAt: new Date(),\n      createdAt: new Date(),\n    })\n\n    // Redirect to dashboard (this will throw, which is expected in Next.js)\n    redirect(\"/\")\n  } catch (error) {\n    // If it's a redirect error, let it propagate\n    if (error && typeof error === \"object\" && \"digest\" in error) {\n      throw error\n    }\n\n    const handled = handleError(error)\n    return {\n      success: false,\n      error: handled.message,\n    }\n  }\n}\n\n/**\n * Legacy: Login worker - verifies credentials against company-scoped worker collection\n * Sets session with companyId and workerId on success\n * @deprecated Use loginCompany + selectWorker instead\n * Includes rate limiting and bcrypt password verification\n */\nexport async function loginWorker(\n  companyId: string,\n  workerId: string,\n  password: string\n): Promise<LoginResult> {\n  try {\n    // Validate input\n    const validation = loginWorkerSchema.safeParse({ companyId, workerId, password })\n    if (!validation.success) {\n      return {\n        success: false,\n        error: \"Invalid input. Please check your credentials.\",\n      }\n    }\n\n    // Rate limiting - get IP from headers\n    const headersList = await headers()\n    const forwardedFor = headersList.get('x-forwarded-for')\n    const realIP = headersList.get('x-real-ip')\n    const clientIP = forwardedFor?.split(',')[0]?.trim() || realIP || 'unknown'\n    const rateLimitId = `login:worker:${companyId}:${workerId}:${clientIP}`\n    const rateLimitResult = await rateLimit(rateLimitId, 5, 15 * 60 * 1000)\n\n    if (!rateLimitResult.success) {\n      const retryAfter = Math.ceil((rateLimitResult.resetAt - Date.now()) / 1000)\n      return {\n        success: false,\n        error: `Too many login attempts. Please try again in ${retryAfter} seconds.`,\n      }\n    }\n\n    // Get company-scoped workers collection\n    const workersCollection = await getCompanyCollection<WorkerWithPassword>(\n      companyId,\n      \"workers\"\n    )\n\n    // Find the worker in the company's collection\n    const worker = await workersCollection.findOne({ id: workerId })\n\n    // Use generic error message\n    if (!worker || worker.companyId !== companyId) {\n      return {\n        success: false,\n        error: \"Invalid credentials\",\n      }\n    }\n\n    // Verify password with bcrypt\n    if (!worker.password) {\n      return {\n        success: false,\n        error: \"Invalid credentials\",\n      }\n    }\n\n    const isValid = await bcrypt.compare(password, worker.password)\n    if (!isValid) {\n      return {\n        success: false,\n        error: \"Invalid credentials\",\n      }\n    }\n\n    // Set session with companyId and workerId\n    await setSession(companyId, workerId)\n\n    // Record login session in company's sessions collection\n    const sessionsCollection = await getCompanyCollection(companyId, \"sessions\")\n    await sessionsCollection.insertOne({\n      workerId,\n      companyId,\n      loginAt: new Date(),\n      createdAt: new Date(),\n    })\n\n    // Redirect to dashboard (this will throw, which is expected in Next.js)\n    redirect(\"/\")\n  } catch (error) {\n    // If it's a redirect error, let it propagate\n    if (error && typeof error === \"object\" && \"digest\" in error) {\n      throw error\n    }\n\n    const handled = handleError(error)\n    return {\n      success: false,\n      error: handled.message,\n    }\n  }\n}\n\nexport async function logout(): Promise<void> {\n  const { clearSession } = await import(\"./session\")\n  \n  try {\n    // Clear session cookies\n    await clearSession()\n    \n    // In a real app, you would also:\n    // 1. Invalidate session in database\n    // 2. Log logout event\n    \n    // Redirect to login page\n    redirect(\"/login\")\n  } catch (error) {\n    // Even if clearing session fails, try to redirect\n    redirect(\"/login\")\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 878, "column": 0}, "map": {"version":3,"sources":["file:///Users/bayarbayasgalanulambayar/Downloads/truck-weighing-dashboard/.next-internal/server/app/organizations/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {logout as '00db69d86cc3b8562947f5f5012a7dc7936b0621ed'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}